<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
  </head>

  <body>
    <script>

      // https://www.jianshu.com/p/86267fab4878

// Es5
//函数名和实例化构造名相同且大写（非强制，但这么写有助于区分构造函数和普通函数）
function Person(name,age) {
    this.name = name;
    this.age=age;
}
Person.prototype.say = function(){
    return "我的名字叫" + this.name+"今年"+this.age+"岁了";
}
var obj=new Person("laotie",88);//通过构造函数创建对象，必须使用new 运算符
console.log(obj.say());//我的名字叫laotie今年88岁了

// 1.当使用了构造函数，并且new 构造函数(),后台会隐式执行new Object()创建对象;
// 2.将构造函数的作用域给新对象，（即new Object()创建出的对象），而函数体内的this就代表new Object()出来的对象。
// 3.执行构造函数的代码。
// 4.返回新对象（后台直接返回）;     


// es6
class Person{//定义了一个名字为Person的类
    constructor(name,age){//constructor是一个构造方法，用来接收参数 
      // constructor方法是类的构造函数的默认方法，通过new命令生成对象实例时，自动调用该方法。
        this.name = name;//this代表的是实例对象
        this.age=age;
    }
    say(){//这是一个类的方法，注意千万不要加上function
        return "我的名字叫" + this.name+"今年"+this.age+"岁了";
    }
}
var obj=new Person("laotie",88); 
console.log(obj.say());//我的名字叫laotie今年88岁了
// 1.在类中声明方法的时候，千万不要给该方法加上function关键字
// 2.方法之间不要用逗号分隔，否则会报错




// 8.下面代码的输出是什么?

class Chameleon{
    // colorChange方法是静态的。静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。
    static colorChange(newColor){

    this.newColor = newColor;

    }

    constructor({newColor="green"}={}){

    this.newColor = newColor;

    }

}

const freddie = newChameleon({newColor:"purple"});

freddie.colorChange("orange");

// A:orange

// B:purple

// C:green

// D:TypeError

// 答案:D

// colorChange方法是静态的。静态方法仅在创建它们的构造函数中存在，并且不能传递给任何子级。
// 由于freddie是一个子级对象，函数不会传递，所以在freddie实例上不存在freddie方法：抛出TypeError。
      
    </script>
  </body>
</html>
