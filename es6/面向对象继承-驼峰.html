<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
  </head>

  <body>
    <div>
       
        1. 可根据传入的评分和总数，返回评星结果（用 ★ 和 ☆ 描述） 
        2. 评分必选项，四舍五入，总数可选，大于0的整数，默认为5 
        3. 对于评分为空或小于0、评分大于总数、总数小于0或总数非整数的情况，返回'error' 
        示例： getRate(4, 8); // ★★★★☆☆☆☆ getRate(3.4); // ★★★☆☆ getRate(5, 2); // 'error' getRate(-2); // 'error' getRate(3, 5.5); // 'error'





        现有一个 Animal 类，请用你知道的所有方式编写 Cat 类并继承于 Animal，并说明每个方法的优缺点
       
        function Cat(){ 
       
        }
        
        Cat.prototype = new Animal();
        
        var cat = new Cat();
        
        console.log(cat.name);
       
        cat.eat('fish');
        
        cat.sleep();
        
        console.log(cat instanceof Animal); //true 
       
        console.log(cat instanceof Cat); //true
        
        ​
        
        特点：
        
        非常纯粹的继承关系，实例是子类的实例，也是父类的实例
       
        父类新增原型方法/原型属性，子类都能访问到
       
        简单，易于实现
       
        ​
       
        缺点： 无法实现多继承
       
        创建子类实例时，无法向父类构造函数传参
       
        ​
        
        ​
        在开发中，我们经常会碰到将abc-xyz这类格式的字符串转为AbcXyz形式的驼峰字符串进行处理，例如：hello-world我们希望能够变成驼峰风格的HelloWorld，请编写代码实现这个camelize(str)方法
        
      
        React基于单项数据流，对于组件间的通信支持不够好。业界解决组件间的通信的方案正为此而生。现需要模拟一个全局的EventStore，使得可以满足以下条件，以支持组件间的通信。要求，事件绑定（同一个key可以绑定多个事件）
        
        
    </div>


    <script>
      function camelize(str) {
        var arr = str.split("-");
        var string = "";
        for (var i = 0; i < arr.length; i++) {
          for (var j = 0; j < arr[i].length; j++) {
            if (j == 0) {
              string += arr[i][j].toUpperCase();
            } else {
              string += arr[i][j];
            }
          }
          console.log(string);
        }
      }
      camelize("abc-xsw");
    </script>
    <script>
      var str = getRate(3, 6);
      document.write(str);
      function getRate(score, total = 5) {
        var score = Math.round(score);
        var num = total - score;
        if (
          score == "" ||
          score < 0 ||
          score > total ||
          total <= 0 ||
          total != parseInt(total)
        ) {
          return "error";
        }
        //document.write( +'★');
        var str = "";
        for (var i = 0; i < score; i++) {
          str += "★";
        }
        for (var i = 0; i < num; i++) {
          str += "☆";
        }
        return str;
      }
    </script>

    <script>
      //要实现继承， 先有一个父类
      function Animal(name) {
        // 属性
        this.name = name || "abcd";
        // 方法
        this.sleep = function() {
          console.log(this.name + "睡觉");
          return "sleep";
        };
      }
//原型下添加方法
      Animal.prototype.eat = function(food) {
        console.log(this.name + "正在吃：" + food);
        return "end";
      };

      // 1.原型链继承（核心：将父类的实例作为子类的原型）
      // 子类
      function Cat() {
        this.abc = "111";
      }
      // 将父类的实例作为子类的原型
      Cat.prototype = new Animal("abc");
      Cat.prototype.name = "cat";

      //　Test Code
      var cat = new Cat("123123123");
      console.log(cat.name);
      console.log(cat.eat("fish"));
      console.log(cat.sleep());
      console.log(cat instanceof Animal); //true
      console.log(cat instanceof Cat); //true
      console.log(cat.abc);

      var cat2 = new Cat();
      console.log(cat2.name);
    </script>
  </body>
</html>
